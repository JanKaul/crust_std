# This is a template cbindgen.toml file with all of the default values.
# Some values are commented out because their absence is the real default.
#
# See https://github.com/eqrion/cbindgen/blob/master/docs.md#cbindgentoml
# for detailed documentation of every option here.



language = "C++"



############## Options for Wrapping the Contents of the Header #################

# header = """template<typename T>using ManuallyDrop = T;
# """
# trailer = """
# template<>
# iceberg::Vec<iceberg::StructField>::~Vec(){ crust_free_vec_structfield(*this); }
# template<>
# iceberg::Vec<uint8_t>::~Vec(){ crust_free_vec_u8(*this); }
# """
# include_guard = "my_bindings_h"
pragma_once = true
# autogen_warning = "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"
include_version = false
namespace = "iceberg"
# namespaces = []
using_namespaces = []
sys_includes = ["span"]
includes = []
no_includes = false
after_includes = ""




############################ Code Style Options ################################

braces = "SameLine"
line_length = 100
tab_width = 2
documentation = true
documentation_style = "auto"
documentation_length = "full"
line_endings = "LF" # also "CR", "CRLF", "Native"




############################# Codegen Options ##################################

style = "both"
sort_by = "Name" # default for `fn.sort_by` and `const.sort_by`
usize_is_size_t = true



[defines]
# "target_os = freebsd" = "DEFINE_FREEBSD"
# "feature = serde" = "DEFINE_SERDE"



[export]
include = ["Option","OwnedSlice","OwnedStr"]
exclude = [""]
# prefix = "CAPI_"
item_types = []
renaming_overrides_prefixing = false



[export.rename]


[export.body]
"OwnedSlice" = """
  std::span<T> AsSpan() {
    return { ptr, len };
  }

  inline std::span<const T> AsSpan() const {
    return { ptr, len };
  }
  
  ~OwnedSlice() {
    if (!len)
      return;
    for (auto& val : AsSpan())
      val.~T();
    free(ptr);
    ptr = (T*)alignof(T);
    len = 0; 
  }
"""

[export.mangle]


[fn]
rename_args = "None"
# must_use = "MUST_USE_FUNC"
# no_return = "NO_RETURN"
# prefix = "START_FUNC"
# postfix = "END_FUNC"
args = "auto"
sort_by = "Name"




[struct]
rename_fields = "None"
# must_use = "MUST_USE_STRUCT"
derive_constructor = false
derive_eq = false
derive_neq = false
derive_lt = false
derive_lte = false
derive_gt = false
derive_gte = false




[enum]
rename_variants = "None"
# must_use = "MUST_USE_ENUM"
add_sentinel = false
prefix_with_name = false
derive_helper_methods = false
derive_const_casts = false
derive_mut_casts = false
# cast_assert_name = "ASSERT"
derive_tagged_enum_destructor = true
derive_tagged_enum_copy_constructor = true
enum_class = true
private_default_tagged_enum_constructor = false




[const]
allow_static_const = true
allow_constexpr = false
sort_by = "Name"




[macro_expansion]
bitflags = false






############## Options for How Your Rust library Should Be Parsed ##############

[parse]
parse_deps = false
include = []
exclude = []
clean = false
extra_bindings = []



[parse.expand]
crates = []
all_features = false
default_features = true
features = []
